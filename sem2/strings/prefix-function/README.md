# Префикс-функция. Алгоритм Кнута-Морриса-Пратта
Префикс-функция. Определение
Дана строка ![image](https://user-images.githubusercontent.com/101459465/180604470-27c54abe-066a-408f-bfe9-89b5dacb8d8d.png) Требуется вычислить для неё префикс-функцию, т.е. массив чисел ![image](https://user-images.githubusercontent.com/101459465/180604479-8a128178-4fee-4bdd-a6f8-3b4d04e8ae52.png), где ![image](https://user-images.githubusercontent.com/101459465/180604485-da411bdb-8a84-4644-8f0c-579fe35c8a30.png) определяется следующим образом: это такая наибольшая длина наибольшего собственного суффикса подстроки ![image](https://user-images.githubusercontent.com/101459465/180604494-267927b5-cec9-459a-baa9-6af1beb97dc1.png), совпадающего с её префиксом (собственный суффикс — значит не совпадающий со всей строкой). В частности, значение ![image](https://user-images.githubusercontent.com/101459465/180604512-7720b731-0333-422c-93b3-aa70edb8ab53.png) полагается равным нулю.

Математически определение префикс-функции можно записать следующим образом:

![image](https://user-images.githubusercontent.com/101459465/180604523-e05d64e5-d42d-4712-ab90-a88e95ec4ef8.png)

Например, для строки "abcabcd" префикс-функция равна: [0, 0, 0, 1, 2, 3, 0], что означает:

у строки "a" нет нетривиального префикса, совпадающего с суффиксом;
у строки "ab" нет нетривиального префикса, совпадающего с суффиксом;
у строки "abc" нет нетривиального префикса, совпадающего с суффиксом;
у строки "abca" префикс длины 1 совпадает с суффиксом;
у строки "abcab" префикс длины 2 совпадает с суффиксом;
у строки "abcabc" префикс длины 3 совпадает с суффиксом;
у строки "abcabcd" нет нетривиального префикса, совпадающего с суффиксом.
Другой пример — для строки "aabaaab" она равна: [0, 1, 0, 1, 2, 2, 3].

## Тривиальный алгоритм
Непосредственно следуя определению, можно написать такой алгоритм вычисления префикс-функции:

vector<int> prefix_function (string s) {
	int n = (int) s.length();
	vector<int> pi (n);
	for (int i=0; i<n; ++i)
		for (int k=0; k<=i; ++k)
			if (s.substr(0,k) == s.substr(i-k+1,k))
				pi[i] = k;
	return pi;
}
Как нетрудно заметить, работать он будет за O(n^3), что слишком медленно.

## Эффективный алгоритм
Этот алгоритм был разработан Кнутом (Knuth) и Праттом (Pratt) и независимо от них Моррисом (Morris) в 1977 г. (как основной элемент для алгоритма поиска подстроки в строке).

## Первая оптимизация
Первое важное замечание — что значение ![image](https://user-images.githubusercontent.com/101459465/180604532-75644153-860d-489c-ada0-1dd63a5384ea.png) не более чем на единицу превосходит значение ![image](https://user-images.githubusercontent.com/101459465/180604539-44ebd97d-93ad-4470-b8a1-1f77a048f80d.png) для любого i.

Действительно, в противном случае, если бы ![image](https://user-images.githubusercontent.com/101459465/180604549-c66ae5b2-5d92-4a5d-ad47-4c4600c1e797.png), то рассмотрим этот суффикс, оканчивающийся в позиции i+1 и имеющий длину ![image](https://user-images.githubusercontent.com/101459465/180604561-273c1cfe-f441-4a1a-acd8-f85276ac177e.png) — удалив из него последний символ, мы получим суффикс, оканчивающийся в позиции i и имеющий длину ![image](https://user-images.githubusercontent.com/101459465/180604573-27d308db-ad9b-462a-b1d1-899859f182bf.png), что лучше ![image](https://user-images.githubusercontent.com/101459465/180604578-55a763f0-e1a1-4368-acf3-197b415b00bd.png), т.е. пришли к противоречию. Иллюстрация этого противоречия (в этом примере ![image](https://user-images.githubusercontent.com/101459465/180604591-086c60ab-a5d8-4d9c-be4d-083ce1a00bd4.png)![image](https://user-images.githubusercontent.com/101459465/180604608-17c356dc-2fc6-445e-97b0-044c437fd9ca.png)
![image](https://user-images.githubusercontent.com/101459465/180604612-346e9ab1-dc2a-4f80-ba90-86536a4d4b0a.png)
 должно быть равно 3):

![image](https://user-images.githubusercontent.com/101459465/180604617-946788ac-b561-4035-aafe-7859de8cdfd7.png)

(на этой схеме верхние фигурные скобки обозначают две одинаковые подстроки длины 2, нижние фигурные скобки — две одинаковые подстроки длины 4)

Таким образом, при переходе к следующей позиции очередной элемент префикс-функции мог либо увеличиться на единицу, либо не измениться, либо уменьшиться на какую-либо величину. Уже этот факт позволяет нам снизить асимптотику до O(n^2) — поскольку за один шаг значение могло вырасти максимум на единицу, то суммарно для всей строки могло произойти максимум n увеличений на единицу, и, как следствие (т.к. значение никогда не могло стать меньше нуля), максимум n уменьшений. В итоге получится O(n) сравнений строк, т.е. мы уже достигли асимптотики O(n^2).

## Вторая оптимизация
Пойдём дальше — избавимся от явных сравнений подстрок. Для этого постараемся максимально использовать информацию, вычисленную на предыдущих шагах.

Итак, пусть мы вычислили значение префикс-функции ![image](https://user-images.githubusercontent.com/101459465/180604651-b93684ea-0a9e-4314-99bc-f7c646ae4a41.png) для некоторого i. Теперь, если ![image](https://user-images.githubusercontent.com/101459465/180604660-696164a9-73e4-4ff9-8eac-d4c302908f32.png), то мы можем с уверенностью сказать, что ![image](https://user-images.githubusercontent.com/101459465/180604667-2283ea08-2140-4489-8037-6ba8dc731e3f.png), это иллюстрирует схема:

![image](https://user-images.githubusercontent.com/101459465/180604672-c0969b7b-6e84-44b5-a883-987f1b4bf98d.png)

(на этой схеме снова одинаковые фигурные скобки обозначают одинаковые подстроки)

Пусть теперь, наоборот, оказалось, что ![image](https://user-images.githubusercontent.com/101459465/180604682-c25a729a-b686-4f6e-ad10-6841d4d269e6.png). Тогда нам надо попытаться попробовать подстроку меньшей длины. В целях оптимизации хотелось бы сразу перейти к такой (наибольшей) длине ![image](https://user-images.githubusercontent.com/101459465/180604688-31cf5c06-517a-4687-9886-faaa90664665.png), что по-прежнему выполняется префикс-свойство в позиции i, т.е. ![image](https://user-images.githubusercontent.com/101459465/180604693-73b3cdd8-274f-4a5c-afc6-752188b1f203.png)

![image](https://user-images.githubusercontent.com/101459465/180604698-efc1c48f-cd73-407c-867f-9eb3bbdabc3e.png)

Действительно, когда мы найдём такую длину j, то нам будет снова достаточно сравнить символы s[i+1] и s[j] — если они совпадут, то можно утверждать, что ![image](https://user-images.githubusercontent.com/101459465/180604777-e56719c6-2074-43d0-b2f0-793f747922fa.png). Иначе нам надо будет снова найти меньшее (следующее по величине) значение j, для которого выполняется префикс-свойство, и так далее. Может случиться, что такие значения j кончатся — это происходит, когда j=0. В этом случае, если s[i+1]=s[0], то ![image](https://user-images.githubusercontent.com/101459465/180604787-866e7f5c-3958-42a7-a044-778c2b9989e2.png), иначе ![image](https://user-images.githubusercontent.com/101459465/180604795-537e34ed-1b26-4834-9cc4-1b8585ceca2e.png).

Итак, общая схема алгоритма у нас уже есть, нерешённым остался только вопрос об эффективном нахождении таких длин j. Поставим этот вопрос формально: по текущей длине j и позиции i (для которых выполняется префикс-свойство, т.е.![image](https://user-images.githubusercontent.com/101459465/180604802-0a77bff1-5c35-4c2a-8315-f6708e05008d.png) требуется найти наибольшее k < j, для которого по-прежнему выполняется префикс-свойство:

![image](https://user-images.githubusercontent.com/101459465/180604763-aacf902b-e05b-496e-95fd-75c0417f6a49.png)

После столь подробного описания уже практически напрашивается, что это значение k есть не что иное, как значение префикс-функции ![image](https://user-images.githubusercontent.com/101459465/180604833-0d566f80-b831-461a-aae7-4e1eab768e04.png), которое уже было вычислено нами ранее (вычитание единицы появляется из-за 0-индексации строк). Таким образом, находить эти длины k мы можем за O(1) каждую.

Итоговый алгоритм
Итак, мы окончательно построили алгоритм, который не содержит явных сравнений строк и выполняет O(n) действий.

Приведём здесь итоговую схему алгоритма:

Считать значения префикс-функции ![image](https://user-images.githubusercontent.com/101459465/180604848-80267eb3-a0db-4170-93be-779f52a46bd8.png) будем по очереди: от i=1 к i=n-1 (значение \pi[0] просто присвоим равным нулю).
Для подсчёта текущего значения ![image](https://user-images.githubusercontent.com/101459465/180604854-53fc08c0-db88-4c2f-b858-67db432810d0.png) мы заводим переменную j, обозначающую длину текущего рассматриваемого образца. Изначально j = \pi[i-1].
Тестируем образец длины j, для чего сравниваем символы s[j] и s[i]. Если они совпадают — то полагаем ![image](https://user-images.githubusercontent.com/101459465/180604858-65257756-77fe-4698-82aa-d38fdf83528a.png) = j+1 и переходим к следующему индексу i+1. Если же символы отличаются, то уменьшаем длину j, полагая её равной ![image](https://user-images.githubusercontent.com/101459465/180604839-94b69c45-5165-4fcb-9232-191524b97400.png), и повторяем этот шаг алгоритма с начала.
Если мы дошли до длины j=0 и так и не нашли совпадения, то останавливаем процесс перебора образцов и полагаем ![image](https://user-images.githubusercontent.com/101459465/180604862-898ac1d6-f589-4956-a974-9af513b49bfe.png) = 0 и переходим к следующему индексу i+1.
Реализация
Алгоритм в итоге получился удивительно простым и лаконичным:

vector<int> prefix_function (string s) {
	int n = (int) s.length();
	vector<int> pi (n);
	for (int i=1; i<n; ++i) {
		int j = pi[i-1];
		while (j > 0 && s[i] != s[j])
			j = pi[j-1];
		if (s[i] == s[j])  ++j;
		pi[i] = j;
	}
	return pi;
}
Как нетрудно заметить, этот алгоритм является онлайновым алгоритмом, т.е. он обрабатывает данные по ходу поступления — можно, например, считывать строку по одному символу и сразу обрабатывать этот символ, находя ответ для очередной позиции. Алгоритм требует хранения самой строки и предыдущих вычисленных значений префикс-функции, однако, как нетрудно заметить, если нам заранее известно максимальное значение, которое может принимать префикс-функция на всей строке, то достаточно будет хранить лишь на единицу большее количество первых символов строки и значений префикс-функции.



